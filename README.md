# Coulomb's Canvas: Visualizing Electrostatic Fields

Coulomb's Canvas is a web application designed to calculate and visualize the electric fields and potentials generated by various static charge distributions. Users can define point charges, finite line charges, infinite planes, and charged spherical shells, and then observe the resulting vector fields in 2D slices or 3D volumes.

## Core Physics Principles

The application is built upon fundamental principles of electrostatics:

1.  **Coulomb's Law:** For a point charge `q` at position **r'**, the electric field **E** at a position **r** is given by:
    **E**(**r**) = (1 / (4πε₀)) * (q / |**R**|²) * **R̂**
    where **R** = **r** - **r'** is the vector from the source charge to the observation point, |**R**| is its magnitude, **R̂** = **R** / |**R**| is the unit vector, and ε₀ is the permittivity of free space.

2.  **Gauss's Law:** For distributions with high symmetry (infinite planes, spherical shells), Gauss's Law provides a simpler way to determine the electric field:
    ∮ **E** ⋅ d**A** = Q<sub>enc</sub> / ε₀
    The electric field for these symmetric cases often has a simpler analytical form.

3.  **Superposition Principle:** The total electric field at any point due to a collection of charges is the vector sum of the electric fields produced by each individual charge (or charge element):
    **E**<sub>total</sub> = Σ **E**<sub>i</sub>

4.  **Electric Potential:** The electric potential V is related to the electric field by **E** = -∇V. For a point charge, V(**r**) = (1 / (4πε₀)) * (q / |**R**|). The total potential is the scalar sum of potentials from individual charges.

5.  **Continuous Charge Distributions:** For extended objects like lines, planes, or volumes, the charge is distributed with a density (linear λ, surface σ, or volume ρ). The electric field is found by integrating the contributions from infinitesimal charge elements `dq`:
    d**E** = (1 / (4πε₀)) * (dq / |**R**|²) * **R̂**
    **E** = ∫ d**E**
    This often requires numerical integration for finite or complex geometries.

## Project Structure

The project is organized into a Python/Flask backend for calculations and a JavaScript/HTML/CSS frontend for user interaction and visualization.

```
coulomb_canvas/
├── app.py                 # Flask application (API endpoints)
├── physics_core/
│   ├── __init__.py
│   ├── constants.py       # Physical constants (ε₀, Kₑ)
│   ├── distributions.py   # Classes for different charge distributions
│   └── system.py          # Manages multiple distributions and superposition
├── templates/
│   └── index.html         # Main web page (UI)
├── static/
│   ├── js/
│   │   └── main.js        # Frontend JavaScript (Plotly, API calls, UI logic)
│   └── css/
│       └── style.css      # Styling for the web page
└── requirements.txt       # Python dependencies
```

## Detailed Code Implementation

### 1. Physics Core (`physics_core/`)

This Python package forms the heart of the simulation engine.

#### `constants.py`
Defines fundamental physical constants:
*   `EPSILON_0`: Permittivity of free space.
*   `K_E`: Coulomb's constant (1 / (4πε₀)).

#### `distributions.py`
Contains the object-oriented representation of charge distributions.

*   **`ChargeDistribution(ABC)` (Abstract Base Class):**
    *   Defines the interface for all charge distributions.
    *   Abstract methods:
        *   `get_electric_field(x, y, z) -> np.ndarray`: Returns the (Ex, Ey, Ez) vector.
        *   `get_potential(x, y, z) -> float`: Returns the scalar potential.
        *   `to_dict() -> dict`: Serializes the distribution.
        *   `from_dict(cls, data: dict) -> 'ChargeDistribution'`: Deserializes.

*   **Concrete Distribution Classes:**
    *   **`PointCharge(ChargeDistribution)`:**
        *   Stores `charge_q` and `position` (NumPy array).
        *   `get_electric_field`: Implements Coulomb's Law directly. Handles singularity at the charge location by returning [0,0,0].
        *   `get_potential`: Implements V = Kₑq/r. Handles singularity.
    *   **`InfinitePlaneCharge(ChargeDistribution)`:**
        *   Stores `surface_charge_density_sigma`, `normal_vector` (normalized), and `point_on_plane`.
        *   `get_electric_field`: Uses the formula E = σ / (2ε₀), with direction determined by the sign of the dot product between the vector from plane to point and the normal. Handles points on the plane.
        *   `get_potential`: Calculates V = -Ed, assuming V=0 on the plane.
    *   **`ChargedSphereShell(ChargeDistribution)`:**
        *   Stores `total_charge_q`, `radius`, and `center`.
        *   `get_electric_field`:
            *   Inside (r < R): E = 0.
            *   Outside (r > R): E = KₑQ/r² (acts like a point charge at the center).
            *   On surface (r ≈ R): Uses the outside field formula.
        *   `get_potential`:
            *   Inside (r < R): V = KₑQ/R (constant).
            *   Outside (r > R): V = KₑQ/r.
    *   **`FiniteLineCharge(ChargeDistribution)`:** (Charged Bar)
        *   Stores `total_charge_q`, `start_point` (p1), and `end_point` (p2).
        *   Calculates line `length` and linear charge density `lambda_val = q / length`.
        *   Handles `is_point_like` case if length is very small.
        *   `_distance_point_to_segment()`: Helper to find the shortest distance from an observation point to the line segment, used to handle singularities on the line.
        *   `get_electric_field`:
            *   If the observation point is very close to the line segment, returns [0,0,0] to avoid numerical instability during visualization.
            *   Otherwise, numerically integrates d**E** along the line using `scipy.integrate.quad`. The integrand for each component (Ex, Ey, Ez) is derived from Coulomb's law for a differential charge element `dq = λ dl = q dt_param` (where `t_param` goes from 0 to 1 along the line).
                dE<sub>x</sub> = Kₑ dq (x - x') / |**R**|³  =>  Integrand for Ex is `Kₑ q * (x_obs - x_line(t)) / |r_obs - r_line(t)|³`.
        *   `get_potential`: Similarly uses `scipy.integrate.quad` to integrate dV = Kₑ dq / |**R**|.
            Integrand for V is `Kₑ q * 1 / |r_obs - r_line(t)|`.

*   **`DISTRIBUTION_CLASSES` (Dictionary):** Maps string identifiers (e.g., `"point_charge"`) to their respective classes.
*   **`create_distribution_from_dict(data: dict)` (Factory Function):** Uses `DISTRIBUTION_CLASSES` to instantiate the correct distribution object from a dictionary (typically from JSON input).

#### `system.py`
Manages a collection of charge distributions.

*   **`ChargeSystem`:**
    *   `distributions`: A list of `ChargeDistribution` objects.
    *   `add_distribution()`, `clear_distributions()`: Basic list management.
    *   `calculate_total_electric_field(x, y, z)`: Iterates through all distributions, calls their `get_electric_field` method, and sums the resulting vectors (superposition). Includes basic error handling for individual distribution calculations.
    *   `calculate_total_potential(x, y, z)`: Similar to above but for scalar potential. Handles `inf`/`NaN` from individual potentials.
    *   `calculate_field_on_grid(x_coords, y_coords, z_coords)`:
        *   Generates a 3D grid of points using `np.meshgrid`.
        *   Iterates through each grid point and calls `calculate_total_electric_field`.
        *   Returns two NumPy arrays: `points` (N x 3 coordinates) and `vectors` (N x 3 field components).
    *   `from_dict_list(cls, dict_list: List[dict])`: Class method to create a `ChargeSystem` from a list of distribution dictionaries.

### 2. Backend (`app.py` - Flask)

Exposes the physics core functionality via a RESTful API.

*   **Flask Setup:** Standard Flask app initialization.
*   **`_parse_range_res(...)` (Helper):** Parses and validates range `[min, max]` and `resolution` parameters from API requests for defining grids/slices. Ensures resolution is at least 2.
*   **API Endpoints:**
    *   **`/` (GET):** Serves the main `index.html` page.
    *   **`/api/calculate_field_at_point` (POST):**
        *   **Input JSON:** `{ "distributions": [...], "point": {"x":v,"y":v,"z":v} }`
        *   **Processing:**
            1.  Parses input JSON.
            2.  Validates `distributions` and `point` data.
            3.  Creates a `ChargeSystem` using `ChargeSystem.from_dict_list()`.
            4.  Calls `system.calculate_total_electric_field()` and `system.calculate_total_potential()`.
        *   **Output JSON:** `{ "Ex":v, "Ey":v, "Ez":v, "E_magnitude":v, "potential":v }`
    *   **`/api/calculate_field_on_slice` (POST):**
        *   **Input JSON:** `{ "distributions": [...], "slice_definition": {"axis":"z", "value":0, "x_range":[-5,5], "y_range":[-5,5], "resolution":20} }`
        *   **Processing:**
            1.  Parses input.
            2.  Creates `ChargeSystem`.
            3.  Determines the fixed coordinate and ranges for the other two axes based on `slice_definition.axis`. Uses `_parse_range_res`.
            4.  Calls `system.calculate_field_on_grid()`.
            5.  Extracts the 2D point coordinates and 2D vector components relevant to the slice plane.
        *   **Output JSON:** `{ "points_dim1":[...], "points_dim2":[...], "vectors_dim1":[...], "vectors_dim2":[...], "axis_labels":["x","y"], ... }`
    *   **`/api/calculate_field_in_volume` (POST):**
        *   **Input JSON:** `{ "distributions": [...], "volume_definition": {"x_range":[-5,5], ..., "resolution":10} }`
        *   **Processing:**
            1.  Parses input.
            2.  Creates `ChargeSystem`.
            3.  Uses `_parse_range_res` for x, y, and z coordinates based on `volume_definition`.
            4.  Calls `system.calculate_field_on_grid()`.
        *   **Output JSON:** `{ "points_x":[...], "points_y":[...], "points_z":[...], "vectors_u":[...], "vectors_v":[...], "vectors_w":[...] }` (u,v,w are Ex,Ey,Ez).
*   **Error Handling:** Endpoints include `try-except` blocks to catch `ValueError` (e.g., from bad input, unknown distribution type) and general exceptions, returning appropriate JSON error responses and HTTP status codes.

### 3. Frontend (`static/` and `templates/index.html`)

Handles user interaction, data submission, and visualization using Plotly.js.

#### `templates/index.html`
*   **Structure:** Standard HTML5 layout with header, main content (configuration and visualization sections), and footer.
*   **Configuration Section:**
    *   Textarea (`#distributionsInput`) for users to input charge distributions as a JSON array. Example JSON and parameter explanations are provided in a `<pre>` block.
    *   Input fields for "Field at a Single Point" (x,y,z coordinates).
    *   Input fields for "Field on a 2D Slice" (slice axis, value, ranges for perpendicular axes, resolution).
    *   Input fields for "Field in a 3D Volume" (x,y,z ranges, resolution).
    *   Buttons to trigger calculations.
*   **Visualization Section:**
    *   `#pointResult` div to display numerical results for single-point calculations.
    *   `#plotDiv2D` and `#plotDiv3D` divs as targets for Plotly.js 2D and 3D plots.
    *   `#statusMessage` div to provide feedback to the user (e.g., "Calculating...", "Error: ...").
*   **Plotly.js CDN:** Included in the `<head>`.

#### `static/css/style.css`
*   Provides styling for a clean and modern user interface.
*   Uses a responsive grid layout for the configuration section.
*   Styles input fields, buttons, result displays, and plot containers.

#### `static/js/main.js`
The core client-side logic.

*   **DOM Element References:** Gets references to all relevant input fields, buttons, and display divs.
*   **Helper Functions:**
    *   `displayError(message)`, `displayStatus(message)`: Update the `#statusMessage` div.
    *   `getDistributions()`: Parses the JSON from `#distributionsInput`, performs basic validation (is array, objects have 'type'), and displays errors.
    *   `parseRange(rangeStr, fieldName)`: Parses "min, max" string into a 2-element number array, validates format, and displays errors. Swaps if min > max.
    *   `getNumericInput(...)`: Parses and validates numeric input fields (checks for `isNaN`, min/max bounds).
    *   `fetchData(endpoint, payload)`:
        *   Handles asynchronous API calls using `fetch`.
        *   Sets "Calculating..." status.
        *   Clears previous results/plots (`Plotly.purge()`).
        *   Sends JSON payload, receives JSON response.
        *   Handles HTTP errors and network errors, displaying them via `displayError`.

*   **Event Listeners for Buttons:**
    *   **`calculatePointBtn`:**
        1.  Validates inputs using helper functions.
        2.  Constructs payload for `/api/calculate_field_at_point`.
        3.  Calls `fetchData`.
        4.  If successful, displays numerical field and potential values in `#pointResult`.
    *   **`calculateSliceBtn`:**
        1.  Validates inputs.
        2.  Constructs payload for `/api/calculate_field_on_slice`.
        3.  Calls `fetchData`.
        4.  If successful:
            *   Clears 3D plot.
            *   **2D Vector Plot (Quiver-like):**
                *   Uses two `scatter` traces:
                    *   One for markers at the start of vectors, colored by magnitude, with a color bar. Hovertemplate shows field components.
                    *   One for lines representing the vectors. Vector lengths are scaled based on `estimated_spacing` and `vectorScaleFactor` to be visually appropriate for the 2D grid.
                *   `Plotly.newPlot()` renders in `#plotDiv2D`. Layout ensures 1:1 aspect ratio (`scaleanchor: "y", scaleratio: 1`).
    *   **`calculateVolumeBtn`:**
        1.  Validates inputs.
        2.  Constructs payload for `/api/calculate_field_in_volume`.
        3.  Calls `fetchData`.
        4.  If successful:
            *   Clears 2D plot.
            *   **3D Cone Plot (`fieldTrace`):**
                *   `type: 'cone'`.
                *   `x, y, z`: Grid point coordinates.
                *   `u, v, w`: **Original, unscaled** electric field components (Ex, Ey, Ez). This is critical for ensuring cone lengths are *relatively* proportional to field strength.
                *   `sizemode: 'absolute'`: This means `sizeref` defines the length of the *largest* cone in data units.
                *   **`sizeref` (named `coneSizerefValue` in code):**
                    *   Calculated to make the largest field vector conspicuous. Primarily based on `avgGridSpacing * 1.5` (meaning the cone for the strongest field will be about 1.5 times the average distance between grid points). This factor (`1.5`) is the main tuning knob for overall cone "bigness".
                    *   Fallbacks are used if `avgGridSpacing` is ill-defined.
                *   `intensity`: Original vector magnitudes, used for `colorscale` (`Plasma`) and color bar.
                *   `hovertemplate`: Shows coordinates, original |E|, and original Ex, Ey, Ez.
                *   `lighting`: Added to cones for better 3D appearance.
            *   **Distribution Visuals (`distributionTraces`):**
                *   The input JSON for distributions is re-parsed to create visual representations of the charges themselves.
                *   **Point Charges:** `scatter3d` markers, colored by charge sign.
                *   **Finite Line Charges:** `scatter3d` lines, colored by charge sign.
                *   **Charged Sphere Shells:** `scatter3d` markers with large, semi-transparent `size` (proportional to sphere radius) to visually suggest a sphere.
                *   **Infinite Planes:** `mesh3d` trace forming a large, semi-transparent rectangular patch. Its orientation is determined by the plane's normal vector, and its size scales with the plot volume. A small cone is also drawn to indicate the normal vector of the plane.
                *   All distribution visuals are added to the plot along with the field cones.
            *   `Plotly.newPlot()` renders in `#plotDiv3D`. Scene uses `aspectmode: 'cube'`.

## Plotting Strategy Summary

*   **2D Slices:** A custom quiver-like plot using scaled lines and magnitude-colored markers. Lengths are scaled for visual clarity within the 2D grid.
*   **3D Volumes:**
    *   **Field Vectors:** Plotly `cone` traces. Cone lengths are *relatively proportional* to the true electric field strength. The *absolute scale* of these cones is controlled by the `sizeref` parameter, which is dynamically calculated to make the strongest field vector in the scene appear at a conspicuous size (e.g., 1.5 times the average grid spacing).
    *   **Charge Distributions:** Geometric primitives (points, lines, large markers for spheres, rectangular meshes for planes) are overlaid to provide context for the field sources.
    *   **Color Mapping:** Vector cones and 2D markers are colored according to the magnitude of the electric field, using a perceptually uniform colorscale (`Plasma` or `Viridis`).
    *   **Interactivity:** Plotly provides built-in zoom, pan, and rotation for 3D plots. Hovering over vectors or markers displays detailed information.

## Future Enhancements

*   GUI for adding/editing charge distributions (instead of raw JSON).
*   More sophisticated `mesh3d` for spheres.
*   Visualization of electric potential (e.g., contour plots on slices, isosurfaces in 3D).
*   Field line tracing.
*   Support for more complex geometries (e.g., charged cylinders, boxes with volume charge) possibly requiring more advanced numerical integration or boundary element methods.
*   Performance optimization for very high-resolution grids (e.g., WebAssembly for core physics, WebGL for custom rendering).
